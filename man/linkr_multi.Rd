% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/linkr_multi.R
\name{linkr_multi}
\alias{linkr_multi}
\title{Locally Optimal Linking Of Many Data Frames}
\usage{
linkr_multi(
  df,
  by,
  slice,
  strata = NULL,
  method = "osa",
  assignment = TRUE,
  na_matches = "na",
  pool = "last",
  caliper = Inf,
  C = 1,
  verbose = FALSE,
  ...
)
}
\arguments{
\item{df}{data frame to link.}

\item{by}{character vector of the key variable(s) to join by. To join by different variables on x and y, use a named vector. For example, by = c("a" = "b") will match x$a to y$b.}

\item{slice}{used to split \code{df} into a list of data frames.}

\item{strata}{character vector of variables to join exactly if any. Can be a named vector as for \code{by}.}

\item{method}{the name of the distance metric to measure the similarity between the key columns.}

\item{assignment}{should one-to-one assignments be constructed?}

\item{na_matches}{should NA and NaN values match one another for any exact join defined by \code{strata}?}

\item{pool}{one of four string values: "previous", "average", "last" or "random" (see details).}

\item{caliper}{caliper value on the same scale as the distance matrix (before multipled by \code{C}).}

\item{C}{scaling parameter for the distance matrix.}

\item{verbose}{print distance summary statistic.}

\item{...}{parameters passed to distance metric function.}
}
\description{
Links a series of data frames sequentially: At each iteration, the function selects one element from all already matched tuples (found by linking data frame \code{1...d}) and links it to the next data frame \code{d+1} until no more data frames are available. All elements of a tuple are assigned the same identifier in the stacked data frame. Each tuple will include at most one element from every data frame \code{d}. The solution is a local approximation to the globally optimal solution.
}
\details{
Splits \code{df} by \code{slice} into a list of data frames (indexed 1,...,d,...,D) and applies \code{linkr} to every element of this list. Each data frame \code{d} is linked to a pool of candidates. The candidate pool is defined by one observation from each matched tuple (which might only have a single element, i.e. a singleton) found in the data frames indexed \code{1...(d-1)}. By default, the last observation for each matched tuple is used (\code{pool='last'}). Other options to construct the candidate pool include:

\itemize{
\item \code{pool='random'}: pool includes a randomly drawn element from each matched tuple.
\item \code{pool='previous'}: pool includes all observations from the data frame indexed \code{d-1}.
\item \code{pool='average'}: pool includes a new observation with the average value per key variable for every matched tuple. This option will only work when the variable(s) defined by the parameter \code{by} are numeric.
}

For more details see the help file of \code{\link[lychee]{linkr}}.
}
\examples{

library(dplyr)
data(greens3)

linkr_multi(
  df=filter(greens3, election=="BTW"), 
  by='city', 
  slice='year',
  method='lcs',
  caliper=15) \%>\% 
arrange(match_id,year) \%>\% 
 data.frame


}
\seealso{
\code{\link[adagio]{assignment}} \code{\link[lychee]{linkr}}
}
